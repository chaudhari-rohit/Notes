![](https://img.shields.io/static/v1?label=Author&message=Rohit+Chaudhari&color=339933&logo=Apache)
![](https://img.shields.io/static/v1?label=Java&message=8&color=27AE60&logo=Java)

Notes

----------------------------------------------------

- Why non static variable be referenced from static context in Java ?
    - When we mark some variable or method as non static we are saying that `this member needs an object to work`. Static variables are saying `I am a class level member`. So to access instance level from class level would break this. Hence noe allowed.
      

- For a method can we have same param type and different return type?
    - `No`. For Overloading param must be different. We can though have diff params and different 
      return types.
      > Why method overloading is not possible by changing the return type in java?
      >
      > In C++ and Java, functions can not be overloaded if they differ only in the return type. 
      The return type of functions is not a part of the mangled name which is generated by the compiler for uniquely identifying each function. The No of arguments, Type of arguments & Sequence of arguments are the parameters which are used to generate the unique mangled name for each function. It is on the basis of these unique mangled names that compiler can understand which function to call even if the names are same(overloading).

- Inheritance vs Composition
    - Prefer Inheritance when `is a` relationship & Composition when `has a` relationship.
    - With Inheritance we must be sure that base class is entirely substitutable for the parent. 
      It in one way mandates that we must interact with the derived class in some set way.
      
- Runtime Polymorphism
    - ` Parent parent = new Child();` Only way allowed. Why ? Because Child has got acess to all 
      parents method and thus is guarented to always get the method referenced from Parent 
      reference. The other way round is not guaranted.
      - ```java
          Parent p = new Parent();
          p.parentOnly();
          p.common();
          Child child = new Child();
          child.childOnly();
          child.common();
          child.parentOnly();
          Parent parent = new Child();
          parent.parentOnly();
          parent.common();
        ```
    - We get a `ClassCastException` a `RuntimeException` if we do the oppostite by force. And 
      compile time error if we do this `Child child = new Parent();`
      - ```java
        @Test(expected = ClassCastException.class)
        public void testChildReferenceInstatiatedWithParentConstructor() {
            Child child = (Child) new Parent();
            child.childOnly();
        
            child.common();
        }
        ```
        
- How to make any class Immutable (where once set the state does not change) ?
    -  First we need to remove all setters and all methods which allow the state to be changed. 
       Now there are 2 cases:
       If the member fields are
       - `Immutable` : then the only change we need is to make them private and final and provide 
         only getters.
       - `Mutable (Normal)` : then we need to ensure that getters and constructors maintain deep 
         copy. Reason being the object is prone to change from reference. From getter we can get 
         reference to the field and as it is mutable we can change the state hence making the 
         enitre object mutable. Similarly if we pass reference to constructor we can change the 
         object state from that reference as well. So to prevent this we maintain deep copies.
      > https://dzone.com/articles/immutable-objects-in-java
         
- Java Pass by Value or Reference?
    - Java is Pass by Value.For primitive its clear. For Objects we actually pass the reference 
      as value. so not the `reference itself but reference value` so when passed like this the 
      new variable has the passed reference value. So operations on the variable will not impact 
      the variable which had original reference. Operation using the copied reference will 
      impact the original variable.
      ```java
        public static void main(String[] args){
          Foo f = new Foo("f");
          changeReference(f); // It won't change the reference!
          modifyReference(f); // It will change the object that the reference variable "f" refers to!
        }
        public static void changeReference(Foo a) {
          Foo b = new Foo("b");
          a = b;
        }
        public static void modifyReference(Foo c) {
          c.setAttribute("c");
        }
      ```
      

