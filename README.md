![](https://img.shields.io/static/v1?label=Author&message=Rohit+Chaudhari&color=339933&logo=Apache)
![](https://img.shields.io/static/v1?label=Java&message=8&color=27AE60&logo=Java)

Notes

----------------------------------------------------

- Why non static variable be referenced from static context in Java ?
    - When we mark some variable or method as non static we are saying that `this member needs an object to work`. Static variables are saying `I am a class level member`. So to access instance level from class level would break this. Hence noe allowed.
      

- For a method can we have same param type and different return type?
    - `No`. For Overloading param must be different. We can though have diff params and different 
      return types.
      > Why method overloading is not possible by changing the return type in java?
      >
      > In C++ and Java, functions can not be overloaded if they differ only in the return type. 
      The return type of functions is not a part of the mangled name which is generated by the compiler for uniquely identifying each function. The No of arguments, Type of arguments & Sequence of arguments are the parameters which are used to generate the unique mangled name for each function. It is on the basis of these unique mangled names that compiler can understand which function to call even if the names are same(overloading).

- Inheritance vs Composition
    - Prefer Inheritance when `is a` relationship & Composition when `has a` relationship.
    - With Inheritance we must be sure that base class is entirely substitutable for the parent. 
      It in one way mandates that we must interact with the derived class in some set way.
      
- Runtime Polymorphism
    - ` Parent parent = new Child();` Only way allowed. Why ? Because Child has got acess to all 
      parents method and thus is guarented to always get the method referenced from Parent 
      reference. The other way round is not guaranted.
      - ```java
          Parent p = new Parent();
          p.parentOnly();
          p.common();
          Child child = new Child();
          child.childOnly();
          child.common();
          child.parentOnly();
          Parent parent = new Child();
          parent.parentOnly();
          parent.common();
        ```
    - We get a `ClassCastException` a `RuntimeException` if we do the oppostite by force. And 
      compile time error if we do this `Child child = new Parent();`
      - ```java
        @Test(expected = ClassCastException.class)
        public void testChildReferenceInstatiatedWithParentConstructor() {
            Child child = (Child) new Parent();
            child.childOnly();
            child.common();
        }
        ```
      
